### ./DECOMPOSITION.md ###
# Декомпозиция проекта «TechMarket API»

## 1. Проектирование и подготовка архитектуры

### 1.1 Анализ предметной области
Проект представляет собой headless-приложение (REST API) для размещения и покупки техники (новой и б/у).

Основные участники системы:
- Пользователь (покупатель/продавец)
- Администратор

Основные сущности:
- User
- Listing (объявление)
- Deal (сделка)

---

### 1.2 Формирование требований

#### Функциональные требования:
- Регистрация и авторизация пользователей
- Создание, редактирование и удаление объявлений
- Фильтрация и пагинация объявлений
- Создание и подтверждение сделок
- Управление статусами объявлений

#### Нефункциональные требования:
- Безопасность (JWT-аутентификация)
- Масштабируемость
- Контейнеризация
- Поддержка линтинга и автоформатирования
- Наличие unit-тестов

---

### 1.3 Проектирование архитектуры

Архитектурный стиль:
- Layered Architecture (Controller → Service → Repository)

Стек технологий:
- Java 17
- Spring Boot
- PostgreSQL
- Docker

API versioning:
- /api/v1/

---

### 1.4 Проектирование базы данных

Таблицы:
- users
- listings
- deals

Связи:
- User 1:N Listing
- User 1:N Deal
- Listing 1:1 Deal

---

## 2. Реализация бизнес-логики

### 2.1 Аутентификация и авторизация
- Регистрация пользователя
- Вход в систему
- Генерация JWT
- Разграничение ролей (USER / ADMIN)

---

### 2.2 Работа с объявлениями

Функции:
- Создание объявления
- Редактирование
- Удаление
- Получение списка
- Фильтрация по:
  - бренду
  - цене
  - состоянию
- Пагинация
- Сортировка

---

### 2.3 Работа со сделками

Функции:
- Создание запроса на покупку
- Подтверждение сделки продавцом
- Изменение статуса объявления (active → reserved → sold)
- Завершение сделки

---

### 2.4 Обработка ошибок

- Глобальный Exception Handler
- Единый формат ответа с ошибкой
- Корректные HTTP-статусы

---

## 3. Обеспечение качества кода

### 3.1 Линтер
Подключение статического анализатора кода (например, Checkstyle).

---

### 3.2 Code Style Fixer
Использование инструмента автоформатирования кода (google-java-format).

---

### 3.3 Unit-тестирование
- Тестирование сервисного слоя
- Тестирование бизнес-логики
- Использование JUnit и Mockito
- Минимальное покрытие 60%

---

### 3.4 Git Hooks
- Настройка pre-commit hook
- Автоматический запуск линтера и тестов перед коммитом

---

### 3.5 CI (GitHub Actions)
- Автоматическая сборка проекта
- Проверка линтера
- Запуск unit-тестов

---

## 4. Документация и развертывание

### 4.1 Документация API
- Интеграция Swagger (OpenAPI)
- Описание всех эндпоинтов
- Примеры запросов и ответов

---

### 4.2 README.md
README должен содержать:
- Описание проекта
- Стек технологий
- Инструкцию по запуску
- Описание API
- Пример запуска через Docker

---

### 4.3 Контейнеризация

- Dockerfile для backend-приложения
- docker-compose для запуска:
  - backend
  - PostgreSQL
- Использование переменных окружения

---

### 4.4 Финальное тестирование
- Проверка запуска через Docker
- Проверка всех эндпоинтов
- Проверка корректности работы бизнес-логики
### ./architecture/architecture_01.md ###
Раздел 1. Проектирование и подготовка архитектуры

1.1 Анализ предметной области

Разрабатываемая система «TechMarket API» представляет собой headless-приложение (REST API) для размещения объявлений о продаже техники (новой и бывшей в употреблении) и заключения сделок между пользователями.

Система предназначена для:
 • размещения объявлений о продаже техники;
 • поиска и фильтрации предложений;
 • взаимодействия продавца и покупателя;
 • фиксации факта совершения сделки.

Основные участники системы:
 1. Пользователь (USER)
 • может размещать объявления;
 • просматривать объявления;
 • инициировать сделки;
 • управлять своими объявлениями.
 2. Администратор (ADMIN)
 • управляет пользователями;
 • может модерировать объявления;
 • имеет расширенные права доступа.

⸻

1.2 Формирование требований

Функциональные требования

Система должна обеспечивать:
 1. Регистрацию и аутентификацию пользователей.
 2. Управление ролями пользователей.
 3. Создание, редактирование и удаление объявлений.
 4. Фильтрацию и пагинацию объявлений.
 5. Создание и подтверждение сделок.
 6. Изменение статусов объявлений:
 • ACTIVE
 • RESERVED
 • SOLD

⸻

Нефункциональные требования
 1. Безопасность:
 • JWT-аутентификация
 • Защита эндпоинтов
 2. Поддержка REST API стандартов.
 3. Масштабируемость архитектуры.
 4. Контейнеризация через Docker.
 5. Использование линтера и автоформатирования.
 6. Наличие unit-тестов.
 7. Автоматическая проверка через GitHub Actions.

⸻

1.3 Выбор архитектурного стиля

Для проекта выбрана многослойная архитектура (Layered Architecture).

Структура слоёв:

Controller (REST API)
        ↓
Service (Бизнес-логика)
        ↓
Repository (Работа с БД)
        ↓
Database (PostgreSQL)

Причины выбора:
 • Простота реализации
 • Понятность структуры
 • Соответствие enterprise-подходу
 • Удобство тестирования

⸻

1.4 Выбор технологического стека

Backend:
 • Java 17
 • Spring Boot

База данных:
 • PostgreSQL

Документация API:
 • Swagger / OpenAPI

Тестирование:
 • JUnit
 • Mockito

Контейнеризация:
 • Docker
 • docker-compose

Контроль качества:
 • Checkstyle
 • google-java-format
 • Git hooks
 • GitHub Actions

⸻

1.5 Проектирование структуры базы данных

Таблица users

Поле Тип Описание
id UUID Идентификатор
email VARCHAR Email пользователя
password VARCHAR Хеш пароля
role ENUM USER / ADMIN
created_at TIMESTAMP Дата регистрации


⸻

Таблица listings

Поле Тип Описание
id UUID Идентификатор
title VARCHAR Название
brand VARCHAR Бренд
price DECIMAL Цена
condition ENUM NEW / USED
status ENUM ACTIVE / RESERVED / SOLD
owner_id UUID Владелец
created_at TIMESTAMP Дата создания


⸻

Таблица deals

Поле Тип Описание
id UUID Идентификатор
listing_id UUID Объявление
buyer_id UUID Покупатель
status ENUM PENDING / APPROVED / COMPLETED
created_at TIMESTAMP Дата создания


⸻

1.6 Проектирование REST API

Базовый путь:

/api/v1/

Примеры:

POST   /api/v1/auth/register
POST   /api/v1/auth/login

GET    /api/v1/listings
POST   /api/v1/listings
PATCH  /api/v1/listings/{id}
DELETE /api/v1/listings/{id}

POST   /api/v1/deals
PATCH  /api/v1/deals/{id}

Принципы:
 • Использование существительных в URL
 • Правильные HTTP-методы
 • Корректные статус-коды
 • Единый формат ответа об ошибке

### ./src/main/java/com/techmarket/dto/RegisterRequest.java ###
package com.techmarket.dto;

public class RegisterRequest {

    private String email;
    private String password;
    private String role;

    public RegisterRequest() {}

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }
}### ./src/main/java/com/techmarket/dto/AuthResponse.java ###
package com.techmarket.dto;

public class AuthResponse {

    private String token;

    public AuthResponse() {}

    public AuthResponse(String token) {
        this.token = token;
    }

    public String getToken() {
        return token;
    }

    public void setToken(String token) {
        this.token = token;
    }
}### ./src/main/java/com/techmarket/dto/LoginRequest.java ###
package com.techmarket.dto;

public class LoginRequest {

    private String email;
    private String password;

    public LoginRequest() {}

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}### ./src/main/java/com/techmarket/controller/AuthController.java ###
package com.techmarket.controller;

import com.techmarket.dto.*;
import com.techmarket.service.AuthService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/register")
    public AuthResponse register(@RequestBody RegisterRequest request) {
        return authService.register(request);
    }

    @PostMapping("/login")
    public AuthResponse login(@RequestBody LoginRequest request) {
        return authService.login(request);
    }
}### ./src/main/java/com/techmarket/controller/HomeController.java ###
package com.techmarket.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HomeController {
    @GetMapping("/")
    public String home() {
        return "TechMarket API is running!";
    }
}
### ./src/main/java/com/techmarket/TechMarketApiApplication.java ###
package com.techmarket;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TechMarketApiApplication {

    public static void main(String[] args) {
        SpringApplication.run(TechMarketApiApplication.class, args);
    }
}### ./src/main/java/com/techmarket/repository/UserRepository.java ###
package com.techmarket.repository;

import com.techmarket.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;
import java.util.UUID;

public interface UserRepository extends JpaRepository<User, UUID> {

    Optional<User> findByEmail(String email);

    boolean existsByEmail(String email);
}### ./src/main/java/com/techmarket/security/CustomUserDetailsService.java ###
package com.techmarket.security;

import com.techmarket.model.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Collections;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        // Пример: на проде нужно брать из базы
        User user = new User();
        user.setEmail(email);
        user.setPassword("$2a$10$hashedpassword"); // BCrypt
        user.setRole("USER");

        return org.springframework.security.core.userdetails.User
                .withUsername(user.getEmail())
                .password(user.getPassword())
                .authorities(user.getRole())
                .build();
    }
}### ./src/main/java/com/techmarket/config/SecurityConfig.java ###
package com.techmarket.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
.requestMatchers("/**").permitAll()
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter,
                        UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}### ./src/main/java/com/techmarket/config/JwtAuthenticationFilter.java ###
package com.techmarket.config;

import com.techmarket.service.JwtService;
import com.techmarket.security.CustomUserDetailsService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final CustomUserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtService jwtService,
                                   CustomUserDetailsService userDetailsService) {
        this.jwtService = jwtService;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String jwt = authHeader.substring(7);
        String email = jwtService.extractEmail(jwt);

        if (email != null &&
                SecurityContextHolder.getContext().getAuthentication() == null) {

            UserDetails userDetails =
                    userDetailsService.loadUserByUsername(email);

            UsernamePasswordAuthenticationToken authToken =
                    new UsernamePasswordAuthenticationToken(
                            userDetails,
                            null,
                            userDetails.getAuthorities()
                    );

            authToken.setDetails(
                    new WebAuthenticationDetailsSource().buildDetails(request)
            );

            SecurityContextHolder.getContext().setAuthentication(authToken);
        }

        filterChain.doFilter(request, response);
    }
}### ./src/main/java/com/techmarket/service/JwtService.java ###
package com.techmarket.service;

import com.techmarket.model.User;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;

@Service
public class JwtService {

    private final String SECRET = "mysecretkeymysecretkeymysecretkeymysecretkey";
    private final Key key = Keys.hmacShaKeyFor(SECRET.getBytes());

    public String generateToken(User user) {
        return Jwts.builder()
                .setSubject(user.getEmail())
                .claim("role", user.getRole())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 86400000))
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();
    }

    public String extractEmail(String token) {
        return extractClaims(token).getSubject();
    }

    private Claims extractClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }
}### ./src/main/java/com/techmarket/service/AuthService.java ###
package com.techmarket.service;

import com.techmarket.dto.LoginRequest;
import com.techmarket.dto.RegisterRequest;
import com.techmarket.dto.AuthResponse;
import com.techmarket.model.User;
import com.techmarket.repository.UserRepository;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;

    public AuthService(UserRepository userRepository,
                       PasswordEncoder passwordEncoder,
                       JwtService jwtService) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.jwtService = jwtService;
    }

    public AuthResponse register(RegisterRequest request) {

        User user = new User(
                request.getEmail(),
                passwordEncoder.encode(request.getPassword()),
                request.getRole()
        );

        userRepository.save(user);

        String token = jwtService.generateToken(user);

        return new AuthResponse(token);
    }

    public AuthResponse login(LoginRequest request) {

        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new RuntimeException("User not found"));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new RuntimeException("Invalid password");
        }

        String token = jwtService.generateToken(user);

        return new AuthResponse(token);
    }
}### ./src/main/java/com/techmarket/model/Role.java ###
package com.techmarket.model;

public enum Role {
    USER,
    ADMIN
}### ./src/main/java/com/techmarket/model/User.java ###
package com.techmarket.model;

import jakarta.persistence.*;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String email;
    private String password;
    private String role;

    public User() {}

    public User(String email, String password, String role) {
        this.email = email;
        this.password = password;
        this.role = role;
    }

    public Long getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }
}